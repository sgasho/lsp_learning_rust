
# Lesson 1-21: コードの使われている場所を探そう！ (LSP参照の検索)

LSPの定義へ移動機能ができるようになりましたね。素晴らしいです！

次に、言語サーバーの非常に強力な機能の一つである「**参照の検索 (Find References)**」について学びます。エディタが特定のシンボルの参照場所を要求したときに、言語サーバーがどのようにその場所を返すのか、その形式と作成方法を学びます。

## 参照の検索 (Find References) とは？

参照の検索機能は、コード中の変数名や関数名などが「どこで使われているか」をすべて見つけ出す機能です。これにより、コードの変更がどこに影響するかを把握したり、リファクタリングの際に役立てたりすることができます。

エディタは、ユーザーが参照の検索を要求すると、言語サーバーに `textDocument/references` リクエストを送ります。サーバーはこれに対して、参照場所のリスト（`Location` オブジェクトの配列）を返します。

## `lsp-types::Location` の構造

`Location` の構造は、Lesson 1-20で学んだ定義へ移動と同じです。`uri` と `range` を持ちます。

## コードの単語を特定し、すべての参照を検索する

ホバー機能や定義へ移動機能と同様に、まずカーソル位置にある「単語」を特定する必要があります。Lesson 1-19で実装した単語抽出ロジックを再利用できます。

今回のレッスンでは、シンプルに「`my_variable`」という単語がカーソル位置にあれば、その単語がコード全体で出現する場所をすべて見つけ出します。見つかったすべての場所を `Location` オブジェクトとしてリストにまとめます。

文字列内で特定のサブ文字列を検索するには、`str::find()` や `str::match_indices()` といったメソッドが便利です。`match_indices()` は、マッチした部分の開始バイトインデックスと文字列そのものをイテレータで返してくれるので、これを使って `Range` を構築できます。

**ヒント:**
*   `file_content.lines().enumerate()` で行番号と行の内容を取得します。
*   各行に対して、`line.match_indices(keyword)` を使って、キーワードが出現するすべての位置を見つけます。
*   見つかった位置ごとに `Location` オブジェクトを作成し、`Vec<Location>` に追加します。

## やってみよう！

あなたの今回のミッションは、`find_references` 関数を完成させることです。

1.  `document_store` から `file_uri` に対応するファイルの内容を取得します。見つからなければ空の `Vec<Location>` を返します。
2.  `position.line` と `position.character` を使って、カーソル位置にある単語を特定します。Lesson 1-19で使った単語抽出ロジックを参考にしてください。
3.  特定した単語が `"my_variable"` であれば、その単語が `file_content` 全体で出現するすべての場所を検索します。
4.  見つかった各出現箇所に対して `Location` オブジェクトを作成し、それらを `Vec<Location>` にまとめて返します。
    *   `Location` の `uri` は `file_uri` を使います。
    *   `Location` の `range` は、出現箇所の開始位置と終了位置（単語の長さ分）を使って `Range::new(Position::new(行番号, 列番号), Position::new(行番号, 列番号 + 単語の長さ))` のように構築します。
5.  それ以外の単語、または単語が特定できない場合は、空の `Vec<Location>` を返します。

`src/lessons/lesson_1_21.rs` を開いて、挑戦しましょう。

`cargo test` でテストがすべて緑色になったらクリアです！
