
# Lesson 1-11: エラーを伝えよう！ (LSPエラー応答の作成)

LSPのリクエストに対して、成功応答を返すことができるようになりましたね。素晴らしいです！

しかし、プログラミングの世界では、常にすべてがうまくいくわけではありません。エディタからのリクエストを処理する際に、何らかのエラーが発生することもあります。そんなとき、言語サーバーはエディタに「**エラー応答 (Error Response)**」を返して、何が問題だったのかを伝える必要があります。

## LSPエラー応答の構造

LSPのエラー応答も、JSON-RPC 2.0の形式に従います。成功応答の `result` フィールドの代わりに、`error` フィールドを含みます。

```json
{
  "jsonrpc": "2.0",
  "id": <リクエストのID>,
  "error": {
    "code": <エラーコード>,
    "message": <エラーメッセージ>,
    "data": <オプションのエラー詳細データ>
  }
}
```

*   `jsonrpc`: 必ず `"2.0"` です。
*   `id`: 応答するリクエストの `id` と同じ値です。エラー応答でも `id` は必須です。
*   `error`: エラーの詳細を含むオブジェクトです。
    *   `code`: エラーの種類を示す数値コードです。LSPには標準のエラーコードがいくつか定義されています（例: `-32601` は「メソッドが見つからない」、`-32602` は「不正なパラメータ」など）。
    *   `message`: 人間が読める形式のエラーの説明です。
    *   `data`: オプションのフィールドで、エラーに関する追加の詳細情報（スタックトレースなど）を格納できます。これは `Value` 型で、どんなJSONでも格納できます。

## Rustでエラー応答メッセージを生成する

成功応答と同様に、`serde_json::json!` マクロを使ってJSON構造を構築し、`serde_json::to_string` で文字列化、そして `Content-Length` ヘッダーを付与します。

`error_data` が `None` の場合は、`error` オブジェクトに `data` フィールドを含めないように注意してください。`json!` マクロは `Option` 型を直接扱うことができるので、`data: error_data` のように書くと、`None` の場合はフィールドが省略されます。

## やってみよう！

あなたの今回のミッションは、`create_lsp_error_response` 関数を完成させることです。

1.  `id`、`error_code`、`error_message`、`error_data` を使って、LSPのエラー応答のJSONコンテンツを構築します。
2.  構築したJSONコンテンツを文字列に変換します。
3.  その文字列のバイト長を計算し、`Content-Length` ヘッダーを付与して、完全なLSPエラー応答メッセージ文字列を返します。

`src/lessons/lesson_1_11.rs` を開いて、挑戦しましょう。

`cargo test` でテストがすべて緑色になったらクリアです！
